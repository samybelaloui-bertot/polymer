export class PropertyManager {
  constructor() {
    this.properties = new Map();
    this.eventHandlers = new Map();
  }

  registerElement(element) {
    this.registerGlobalProperties(element);
    this.registerScopedProperties(element);
  }

  deregisterElement(element) {
    const props = this.getGlobalProperties(element);
    const handler = this.eventHandlers.get(element);
    props.forEach(property => {
      const globalProp = this.properties.get(property.name);

      if (globalProp) {
        globalProp.listeners = globalProp.listeners.filter(listener => listener !== element);

        if (handler && property.notify) {
          element.removeEventListener(this.getEventName(property.name), handler);
          globalProp.notifyers = globalProp.notifyers.filter(listener => listener !== element);
        }
      }
    });
    this.getScopedProperties(element).forEach(prop => {
      const globalProp = this.properties.get(prop.scope);

      if (globalProp) {
        globalProp.scoped = globalProp.scoped.filter(scope => scope.element !== element);
      }
    });
  }

  removeScope(property, value) {
    const globalProp = this.properties.get(property);

    if (globalProp != null) {
      globalProp.scoped.forEach(scope => {
        scope.values.delete(value);
      });
    }
  }

  getEventName(propertyName) {
    let eventName = propertyName + '-changed';
    eventName = eventName.replace(/([A-Z])/g, '-$1');
    return eventName.toLowerCase();
  }

  registerGlobalProperties(element) {
    const props = this.getGlobalProperties(element);
    props.forEach(prop => {
      let globalProp = this.properties.get(prop.name);

      if (globalProp == null) {
        globalProp = {
          name: prop.name,
          value: undefined,
          listeners: [element],
          notifyers: [],
          scoped: []
        };
        this.properties.set(prop.name, globalProp);
      } else {
        if (typeof globalProp.value !== 'undefined') {
          element[prop.name] = globalProp.value;
        }

        globalProp.listeners.push(element);
      }

      if (prop.notify) {
        if (typeof globalProp.value === 'undefined') {
          globalProp.value = element[prop.name];
        }

        this.registerNotifyer(prop, element, globalProp);
      }
    });
  }

  registerScopedProperties(element) {
    const scoped = this.getScopedProperties(element);
    scoped.forEach(prop => {
      let globalProp = this.properties.get(prop.scope);
      const scopeDef = {
        element,
        name: prop.name,
        get: prop.get,
        set: prop.set,
        scope: prop.scope,
        values: new Map()
      };

      if (globalProp == null) {
        globalProp = {
          name: prop.scope,
          value: undefined,
          listeners: [],
          notifyers: [],
          scoped: [scopeDef]
        };
        this.properties.set(globalProp.name, globalProp);
      } else {
        globalProp.scoped.push(scopeDef);
      }
    });
  }

  getDefinition(property) {
    return {
      name: typeof property === 'string' ? property : property.name,
      notify: typeof property === 'string' ? false : property.notify
    };
  }

  registerNotifyer(prop, element, propData) {
    propData.notifyers.push(element);

    if (typeof propData.value === 'undefined') {
      this.updateProperty(propData, element[propData.name]);
    }

    let handler = this.eventHandlers.get(element);

    if (handler == null) {
      handler = event => {
        const namePart1 = event.type.split('-').slice(0, -1);
        const name = namePart1[0] + namePart1.slice(1).map(part => part[0].toUpperCase() + part.slice(1)).join('');
        const globalProp = this.properties.get(name);

        if (globalProp != null) {
          this.updateProperty(globalProp, (event.detail || {}).value);
        }
      };
    }

    this.eventHandlers.set(element, handler);
    element.addEventListener(this.getEventName(prop.name), handler);
  }

  updateProperty(property, value) {
    if (property.value === value) {
      return;
    }

    property.scoped.forEach(scoped => {
      let current = null;

      if (typeof scoped.get === 'function') {
        current = scoped.get.apply(scoped.element);
      } else if (scoped.name != null) {
        current = scoped.element[scoped.name];
      }

      scoped.values.set(property.value, current);

      if (typeof scoped.set === 'function') {
        scoped.set.apply(scoped.element, [scoped.values.get(value), value]);
      }

      if (scoped.name != null) {
        scoped.element[scoped.name] = scoped.values.get(value);
      }
    });
    property.value = value;
    property.listeners.forEach(listener => {
      listener[property.name] = value;
    });
  }

  getGlobalProperties(element) {
    const constructor = element.constructor;

    if (constructor != null && constructor.globals instanceof Array) {
      try {
        return (constructor.globals || []).map(this.getDefinition);
      } catch (_a) {
        return [];
      }
    }

    return [];
  }

  getScopedProperties(element) {
    const constructor = element.constructor;

    if (constructor != null && constructor.scoped instanceof Array) {
      try {
        return constructor.scoped || [];
      } catch (_a) {
        return [];
      }
    }

    return [];
  }

} //# sourceMappingURL=PropertyManager.js.map